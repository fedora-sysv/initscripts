#!/bin/bash
# Network Interface Configuration System
# Copyright (c) 1996-2001 Red Hat, Inc. all rights reserved.
#
# This software may be freely redistributed under the terms of the GNU
# public license.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

. /etc/init.d/functions

cd /etc/sysconfig/network-scripts
. network-functions

[ -f ../network ] && . ../network
[ -f ../networking/network ] && . ../networking/network

CONFIG=${1}

[ -z "${CONFIG}" ] && {
    echo $"Usage: ifup <device name>" >&2
    exit 1
}

need_config ${CONFIG}

[ -f "${CONFIG}" ] || {
    echo $"$0: configuration for ${1} not found." >&2
    echo $"Usage: ifup <device name>" >&2
    exit 1
}

if [ ${UID} != 0 ]; then
    if [ -x /usr/sbin/usernetctl ]; then
	if /usr/sbin/usernetctl ${CONFIG} report ; then
	    exec /usr/sbin/usernetctl ${CONFIG} up
	fi
    fi
    echo $"Users cannot control this device." >&2
    exit 1
fi

source_config

if [ "foo$2" = "fooboot" -a "${ONBOOT}" = "no" -o "${ONBOOT}" = "NO" ]
then
    exit 0
fi
if [ -n "$IN_HOTPLUG" -a "${HOTPLUG}" = "no" -o "${HOTPLUG}" = "NO" ]
then
    exit 0
fi

# figure out more about what we are dealing with
DEVICETYPE=`echo ${DEVICE} | sed "s/[0-9]*$//"`
[ -z "$REALDEVICE" ] && REALDEVICE=`echo ${DEVICE} | sed 's/:.*//g'`
if echo ${DEVICE} | grep -q ':' ; then
    ISALIAS=yes
else
    ISALIAS=no
fi

# Old BOOTP variable
if [ "${BOOTP}" = "yes" ]; then
    BOOTPROTO=bootp
fi

if [ "${BOOTPROTO}" = "bootp" -o "${BOOTPROTO}" = "dhcp" ]; then
    DYNCONFIG=true
fi

if [ -x /sbin/ifup-pre-local ]; then
    /sbin/ifup-pre-local ${DEVICE}
fi

OTHERSCRIPT="/etc/sysconfig/network-scripts/ifup-${DEVICETYPE}"

if [ -x ${OTHERSCRIPT} ]; then
    exec ${OTHERSCRIPT} ${CONFIG} $2
fi

is_available ${REALDEVICE} || {
      if [ "$?" = "1" ] ; then
         echo $"$alias device does not seem to be present, delaying ${DEVICE} initialization."
         exit 1
      else
         exit 0
      fi
}
if [ -n "${HWADDR}" ]; then
    FOUNDMACADDR=`LC_ALL= LANG= ip -o link show ${REALDEVICE} | \
	sed 's/.*link\/ether \([[:alnum:]:]*\).*/\1/'`
    if [ "${FOUNDMACADDR}" != "${HWADDR}" ]; then
        /sbin/nameif "${REALDEVICE}" "${HWADDR}" || {
	   echo $"Device ${DEVICE} has different MAC address than expected, ignoring."
	   exit 1
	}
    fi
fi

# is the device wireless? If so, configure wireless device specifics
is_wireless_device ${DEVICE} && . ./ifup-wireless

if [ "${SLAVE}" = yes -a "${ISALIAS}" = no -a "${MASTER}" != "" -a \
     -x /sbin/ifenslave ]; then
    RFLAG="" ; [ "${RECEIVEONLY}" = yes ] && RFLAG="-r"

    ifconfig ${DEVICE} down
    echo $"Enslaving ${DEVICE} to ${MASTER}"
    ifenslave ${RFLAG} "${MASTER}" "${DEVICE}"

    exit 0
fi

# this isn't the same as the MAC in the configuration filename.  It is
# available as a configuration option in the config file, forcing the kernel
# to think an ethernet card has a different MAC address than it really has.
if [ -n "${MACADDR}" ]; then
   ip link set ${DEVICE} address ${MACADDR}
fi
if [ -n "${MTU}" ]; then
   ip link set ${DEVICE} mtu ${MTU}
fi

# Is there a firewall running, and does it look like one we configured?
FWACTIVE=
if [ -f /etc/sysconfig/ipchains -a \
    "`ipchains -L input -n 2>&1 | \
    awk 'END { print NR }'`" -gt 1 ]; then
    FWACTIVE=1
    export FWACTIVE
fi

# Remove any temporary references which were previously added to dhclient config
if [ -w /etc/dhclient-${DEVICE}.conf ] && [ -x /sbin/dhclient ] ; then
   grep -v "# temporary RHL ifup addition" /etc/dhclient-${DEVICE}.conf > /etc/dhclient-${DEVICE}.conf.ifupnew 2> /dev/null
   cat /etc/dhclient-${DEVICE}.conf.ifupnew > /etc/dhclient-${DEVICE}.conf
   rm -f /etc/dhclient-${DEVICE}.conf.ifupnew
fi
		     
if [ -n "${DYNCONFIG}" ]; then
    PUMPARGS=$PUMPARGS
    DHCPCDARGS="$DHCPCDARGS -n"
    DHCLIENTARGS="${DHCLIENTARGS} -1 -q -lf /var/lib/dhcp/dhclient-${DEVICE}.leases -pf /var/run/dhclient-${DEVICE}.pid -cf /etc/dhclient-${DEVICE}.conf"
    if [ -n "${DHCP_HOSTNAME}" ]; then
       # Send a host-name to the DHCP server (requ. by some dhcp servers).
       PUMPARGS="${PUMPARGS} -h ${DHCP_HOSTNAME}"
       DHCPCDARGS="${DHCPCDARGS} -h ${DHCP_HOSTNAME}"
       if [ -x /sbin/dhclient ] ; then
          if [ -w /etc/dhclient-${DEVICE}.conf ] ; then
             if ! grep "send *host-name *\"${DHCP_HOSTNAME}\"" /etc/dhclient-${DEVICE}.conf > /dev/null 2>&1 ; then
                echo "send host-name \"${DHCP_HOSTNAME}\";  # temporary RHL ifup addition" >> /etc/dhclient-${DEVICE}.conf
             fi
          elif ! [ -e /etc/dhclient-${DEVICE}.conf ] ; then
             echo "send host-name \"${DHCP_HOSTNAME}\";  # temporary RHL ifup addition" >> /etc/dhclient-${DEVICE}.conf
          fi
       fi
    fi
    if need_hostname; then
       # Set hostname of host to host-name option supplied by DHCP.
       PUMPARGS="${PUMPARGS} --lookup-hostname"
       DHCPCDARGS="${DHCPCDARGS} -H"
    fi
    if [ "${PEERDNS}" = "no" ]; then
       # Do not update/replace resolv.conf.
       PUMPARGS="${PUMPARGS} -d"
       DHCPCDARGS="${DHCPCDARGS} -R"
    fi
    echo -n $"Determining IP information for ${DEVICE}..."
    if check_link_down ${DEVICE}; then
	echo $" failed; no link present.  Check cable?"
	ip link set down ${DEVICE} >/dev/null 2>&1
	exit 1
    fi

    # DHCP clients need DNS to be available, and we don't know
    # what DNS server they're using until they are done.
    FWHACK=
    if [ -n "$FWACTIVE" -a "$FIREWALL_MODS" != "no" ]; then
        ipchains -I input -s 0/0 53 -d 0/0 1025:65535 -p udp -j ACCEPT
	FWHACK=1
    fi
    
    if [ -x /sbin/dhclient ] && /sbin/dhclient ${DHCLIENTARGS} ${DEVICE} ; then
	echo $" done."
    elif [ -z "`pidof -x dhclient`" ] && [ -x /sbin/dhcpcd ] && /sbin/dhcpcd ${DHCLIENTARGS} ${DEVICE} ; then
	echo $" done."
    elif [ -z "`pidof -x dhclient`" ] && [ -z "`pidof -x dhcpcd`" ] && [ -x /sbin/pump ] && /sbin/pump ${PUMPARGS} -i ${DEVICE}; then
	echo $" done."
    else
	echo $" failed."
	[ -n "$FWHACK" ] && ipchains -D input -s 0/0 53 -d 0/0 1025:65535 -p udp -j ACCEPT
	exit 1
    fi

    [ -n "$FWHACK" ] && ipchains -D input -s 0/0 53 -d 0/0 1025:65535 -p udp -j ACCEPT
else 
    if [ -z "${IPADDR}" ]; then
         # enable device without IP, useful for e.g. PPPoE
	 ip link set ${REALDEVICE} up
	 if [ "${NETWORKING_IPV6}" = "yes" ]; then
	    /etc/sysconfig/network-scripts/ifup-ipv6 ${CONFIG}
	 fi
	 exec /etc/sysconfig/network-scripts/ifup-post ${CONFIG} ${2}
    fi
  
    expand_config
    
    [ -n "${ARP}${PROMISC}${ALLMULTI}" ] && \
	ip link set ${REALDEVICE} $(toggle_value arp $ARP) \
	   $(toggle_value promisc $PROMISC) \
	   $(toggle_value allmulti $ALLMULTI)
   
    if ! ip link set ${REALDEVICE} up ; then
	echo $"Failed to bring up ${DEVICE}."
	exit 1
    fi

    if ! arping -q -c 2 -w 3 -D -I ${REALDEVICE} ${IPADDR} ; then
	echo $"Error, some other host already uses address ${IPADDR}."
	exit 1
    fi

    if [ "${DEVICE}" = "lo" ]; then
    	SCOPE="scope host"
    else
        SCOPE=
    fi
    
    if [ -n "$SRCADDR" ]; then
       SRC="src $SRCADDR"
    else
       SRC=
    fi
    
    if ! LC_ALL=C ip addr ls ${REALDEVICE} | grep -q "${IPADDR}/${PREFIX}" ; then
	 if ! ip addr add ${IPADDR}/${PREFIX} \
	    brd ${BROADCAST:-+} dev ${REALDEVICE} ${SCOPE} label ${DEVICE}; then
	    echo $"Error adding address ${IPADDR} for ${DEVICE}."
	 fi
    fi
    
    if [ -n "$SRCADDR" ]; then
           sysctl -w "net.ipv4.conf.${REALDEVICE}.arp_filter=1" >/dev/null 2>&1
    fi

    # update ARP cache of neighboring computers
    arping -q -A -c 1 -I ${REALDEVICE} ${IPADDR}
    ( sleep 2;
      arping -q -U -c 1 -I ${REALDEVICE} ${IPADDR} ) > /dev/null 2>&1 < /dev/null &

    # Add a route for the subnet.  Replace any existing route.
    if [ "${ISALIAS}" = no -a "${NETMASK}" != "255.255.255.255" ]; then
	ip route replace ${NETWORK}/${PREFIX} ${SRC} dev ${REALDEVICE}
    fi

    # Set a default route.
    if [ -z "${GATEWAYDEV}" -o "${GATEWAYDEV}" = "${REALDEVICE}" ]; then
	# set up default gateway
	if [ -n "${GATEWAY}" -a "`ipcalc --network ${GATEWAY} ${NETMASK} 2>/dev/null`" = "NETWORK=${NETWORK}" ]; then
	    ip route add default via ${GATEWAY} ${SRC}
	elif [ "${GATEWAYDEV}" = "${DEVICE}" ]; then
	    ip route add default ${SRC} dev ${REALDEVICE}
	fi
    fi
fi

# IPv6 initialisation?
if [ "${NETWORKING_IPV6}" = "yes" ]; then
    /etc/sysconfig/network-scripts/ifup-ipv6 ${CONFIG}
fi

if [ "${IPX}" = yes ]; then
       /etc/sysconfig/network-scripts/ifup-ipx ${DEVICE}
fi

exec /etc/sysconfig/network-scripts/ifup-post ${CONFIG} ${2}

